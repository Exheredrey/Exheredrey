# Copyright 2016 Marc-Antoine Perennou
# Distributed under the terms of the GNU General Public License v2

myexparam crate=${PN}
myexparam rust_minimum_version=1.28.0
myexparam channel=all
myexparam -b disable_default_features=false

exparam -v CRATE crate
exparam -v RUST_CHANNEL channel

HOMEPAGE="http://crates.io/crates/${CRATE}"
if [[ $(type -t scm_src_unpack) == function ]]; then
   DOWNLOADS=""
else
   DOWNLOADS="https://crates.io/api/v1/crates/${CRATE}/${PV}/download -> ${PNV}.tar.gz"
fi

WORK="${WORKBASE}/${CRATE}-${PV}"

if [[ "${CATEGORY}/${PN}" != "dev-lang/rust" ]]; then
    rust_slot_requirement() {
        case ${RUST_CHANNEL} in
            stable|beta|nightly)
                echo ${RUST_CHANNEL}
                ;;
            all)
                echo "*"
                ;;
            same)
                echo "="
                ;;
            *)
                eerror "Invalid channel: ${RUST_CHANNEL}"
        esac
    }

    DEPENDENCIES="
        build:
            dev-lang/rust:$(rust_slot_requirement)[>=$(exparam rust_minimum_version)]
    "
fi

export_exlib_phases src_unpack src_configure src_compile src_test src_install

export CARGO_HOME="${FETCHEDDIR}/cargo-home/"

cargo_get_tool() {
    local tool=${1}

    case ${RUST_CHANNEL} in
        stable|beta|nightly)
            echo ${tool}-${RUST_CHANNEL}
            ;;
        *)
            echo ${tool}
            ;;
    esac
}

ecargo() {
    local cmd="${1}"
    local params=()
    local features=()
    local feature
    local feat

    shift

    if [[ "${cmd}" != "fetch" ]]; then
        if exparam -b disable_default_features; then
            params+=( --no-default-features )
        fi

        for feature in "${ECARGO_FEATURES[@]}"; do
            features+=( ${feature} )
        done
        for feature in "${ECARGO_FEATURE_ENABLES[@]}"; do
            feat=$(option ${feature})
            if [[ -n "${feat}" ]]; then
                features+=( ${feat} )
            fi
        done

        if [[ ${#features[@]} != 0 ]]; then
            params+=( --features "${features[*]}" )
        fi
    fi

    esandbox allow "${CARGO_HOME}"
    RUSTC="${RUSTC:-$(cargo_get_tool rustc)}" RUSTDOC="${RUSTDOC:-$(cargo_get_tool rustdoc)}" edo "${CARGO:-$(cargo_get_tool cargo)}" "${cmd}" "${params[@]}" "${@}"
    esandbox disallow "${CARGO_HOME}"
}

ecargo_fetch() {
    # TODO(keruspe): nuke that when we handle system-wide deps properly
    # This issue would make things better already: https://github.com/rust-lang/cargo/issues/2998
    # Fetch dependencies before further offline processing
    esandbox disable_net
    ecargo fetch
    esandbox enable_net
}

ecargo_config() {
    # Tell cargo to be verbose and respect EXJOBS
    edo mkdir -p .cargo
    cat >> .cargo/config <<EOF
[term]
verbose = true
[build]
jobs = ${EXJOBS:-1}
EOF
}

cargo_src_unpack() {
    if [[ $(type -t scm_src_unpack) == function ]]; then
        scm_src_unpack
    else
        default
    fi

    edo cd "${WORK}"

    ecargo_fetch
}

cargo_src_configure() {
    ecargo_config
}

cargo_src_compile() {
    ecargo build --release
}

cargo_src_test() {
    ecargo test --release
}

ecargo_install() {
    ecargo install --path=. --root="${IMAGE}/usr/$(exhost --target)"
    edo rm "${IMAGE}/usr/$(exhost --target)/.crates.toml"
    [[ -d man/ ]] && doman man/*
}

cargo_src_install() {
    ecargo_install
    emagicdocs
}

